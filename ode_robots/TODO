Changes for Robots

HEADER
remove 
#include <drawstuff/drawstuff.h>
#include "simulation.h"

add
namespace lpzrobots {

#include "primitive.h"
#include "joint.h"

Constructor add 
, const OsgHandle& osgHandle

virtual void place(Position pos , Color *c = 0);
->
/** sets the pose of the vehicle
    @params pose desired 4x4 pose matrix
*/
virtual void place(const osg::Matrix& pose);

virtual Object getMainObject() const { return object[0]; }
->
/** the main object of the robot, which is used for position and speed tracking */
virtual Primitive* getMainPrimitive() const { return object[0]; }

virtual void create(Position pos); 
->
/** creates vehicle at desired pose
    @param pose 4x4 pose matrix
*/
virtual void create(const osg::Matrix& pose); 


Object object[X];
->
Primitive* object[X];

dJointID joint[X]; 
->
Joint* joint[X]; 


dSpaceID vehicle_space;
-> This is for good reason, trust me :-)
dSpaceID parentspace; 

obsolete:
virtual void setTextures(int body, int wheels);

texture variables like bodyTexture ...

CPP
remove 
#include <drawstuff/drawstuff.h>
#include "simulation.h"

add 
namespace lpzrobots {

}

Constructor:
add parameter
, const OsgHandle& osgHandle
and
:  OdeRobot(odehandle, 
->
:  OdeRobot(odehandle, osgHandle

and code:
parentspace = odeHandle.space;


color.r=2;
color.g=156/255.0;
color.b=0/255.0;
->
this->osgHandle.color = Color(2, 156/255.0, 0, 1.0f);

some implenation of place
-> adjust the height!
void Classname::place(const Matrix& pose){
    // the position of the robot is the center of the body (without wheels)
    // to set the vehicle on the ground when the z component of the position is 0
    // width*0.6 is added (without this the wheels and half of the robot will be in the ground)    
    Matrix p2;
    p2 = pose * Matrix::translate(Vec3(0, 0, width*0.6)); 
    create(p2);
    
};

draw() {
drawcode
}
->
update(){
updatecode
}

drawcode moves mainly to create see below
updatecode looks as follows:
    assert(created); // robot must exist
  
    for (int i=0; i<segmentsno; i++) { 
      object[i]->update();
    }
    for (int i=0; i < 4; i++) { 
      joint[i]->update();
    }
    // update sensors like
    irSensorBank.update();  


void Classname::create(Position pos)
->
void Classname::create(const Matrix& pose)

// create vehicle space and add it to the top level space
odeHandle.space = dSimpleSpaceCreate (parentspace);

object[0] = new Capsule(width/2, length);
object[0]->init(odeHandle, cmass, osgHandle);    
// rotate and place body (here by 90° around the y-axis)
object[0]->setPose(Matrix::rotate(M_PI/2, 0, 1, 0) * pose);
object[0]->getOSGPrimitive()->setTexture("Images/wood.rgb");

Please note that the transformations are done via
osg::Matrix::rotate and translate

destroy:

    for (int i=0; i<segmentsno; i++){
      if(object[i]) delete object[i];
    }
    for (int i=0; i<2; i++){
      if(joint[i]) delete joint[i];
    }
    for (int i=0; i<2; i++){
      if(bumper[i].bump) delete bumper[i].bump;
      if(bumper[i].transform) delete bumper[i].transform;
    }
    dSpaceDestroy(odeHandle.space);


collisionCallBack:
vehicle_space 
->
odeHandle.space

world
->
odeHandle.world

object[X].geom
->
object[X]->getGeom()

contactgroup
->
odeHandle.jointGroup


Changes for Simulations:

First of all use the new Makefile form template_onerobot

A simulation is now a class called Simulation.
You should derive your own one and overload the 
start, end, config ... functions. 
However, there is a compatibility class called CompatSim, which can be  
initialised with the callback functions as before.

Remove 
#include <drawstuff/drawstuff.h>
#include <ode/ode.h>


Add:

using namespace lpzrobots;

class ThisSim : public Simulation {
public:
	

Replace:
//Startfunktion die am Anfang der Simulationsschleife, einmal ausgefuehrt wird
void start(const OdeHandle& odeHandle, GlobalData& global) 
->
/// start() is called at the start and should create all the object (obstacles, agents...).
virtual void start(const OdeHandle&, const OsgHandle&, GlobalData& globalData) = 0;


void end(GlobalData& global){
->
/// end() is called at the end and should tidy up
virtual void end(GlobalData& globalData) = 0;

Remove:
// this function is called if the user pressed Ctrl-C
void config(GlobalData& global){

Replace:
dsPrint
-> 
printf
However the "Welcome Message can be ommited!


in main:
Version mit eigener Klasse ThisSim:

ThisSim sim;
return sim.run(argc, argv) ? 0 : 1;

CompatSim version:
CompatSim sim(&start, &end, &config);
return sim.run(argc, argv) ? 0 : 1;





